### 练习

对实验报告的要求：
 - 基于markdown格式来完成，以文本方式为主
 - 填写各个基本练习中要求完成的报告内容
 - 完成实验后，请分析ucore_lab中提供的参考答案，并请在实验报告中说明你的实现与参考答案的区别
 - 列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）
 - 列出你认为OS原理中很重要，但在实验中没有对应上的知识点



# Lab3 缺页异常和页面置换

## 一.实验目的

1.了解虚拟内存的Page Fault异常处理实现

2.了解页替换算法在操作系统中的实现

3.学会如何使用多级页表，处理缺页异常（Page Fault），实现页面置换算法。

## 二.实验过程
### 练习0：填写已有实验

本实验依赖实验2。请把你做的实验2的代码填入本实验中代码中有“LAB2”的注释相应部分。（建议手动补充，不要直接使用merge）


### 练习1：理解基于FIFO的页面替换算法（思考题）
*描述FIFO页面置换算法下，一个页面从被换入到被换出的过程中，会经过代码里哪些函数/宏的处理（或者说，需要调用哪些函数/宏），并用简单的一两句话描述每个函数在过程中做了什么？至少正确指出10个不同的函数分别做了什么？如果少于10个将酌情给分。我们认为只要函数原型不同，就算两个不同的函数。要求指出对执行过程有实际影响,删去后会导致输出结果不同的函数（例如assert）而不是cprintf这样的函数。如果你选择的函数不能完整地体现”从换入到换出“的过程，比如10个函数都是页面换入的时候调用的，或者解释功能的时候只解释了这10个函数在页面换入时的功能，那么也会扣除一定的分数*


FIFO（先进先出）页面置换算法在页面换入和换出过程中会涉及多个函数调用。每个函数的作用具体如下：

1. **`swap_in`**：用于将页面从磁盘换入内存。
   - 通过调用`alloc_page`申请一块新的物理内存，调用`get_pte`获取对应的页表项，最后使用`swapfs_read`从磁盘读取数据到内存中。

2. **`alloc_page`**：用于申请物理页面。
   - 在内存管理器中调用`pmm_manager->alloc_pages`，请求分配一块连续的内存空间。如果分配失败，则会调用`swap_out`换出当前内存中的页面。

3. **`assert(result != NULL)`**：确保页面申请成功。
   - 通过判断返回的页面是否为`NULL`，如果页面为空则会触发错误，避免后续操作出错。

4. **`swap_out`**：用于将页面从内存换出到磁盘。
   - 通过调用`sm->swap_out_victim`选择需要换出的页面，并获取该页面的页表项（`get_pte`）。如果页面被修改过，会调用`swapfs_write`将数据写回磁盘。写入成功后，释放该页面内存；否则调用`_fifo_map_swappable`更新FIFO队列，并刷新TLB。

5. **`free_page`**：释放页面。
   - 调用`pmm_manager->free_pages`释放页面，将其标记为可回收内存，进行内存管理。

6. **`assert((*ptep & PTE_V) != 0);`**：确保页表项合法。
   - 判断页表项的有效位`PTE_V`，确保该页表项是有效的。如果无效，说明页表项不符合交换条件，程序会进入失败状态。

7. **`swapfs_write`**：将页面写回磁盘。
   - 在换出页面时，若页面内容与磁盘上的数据不一致，调用`swapfs_write`将内存中的页面内容写入磁盘。

8. **`tlb_invalidate`**：刷新TLB（Translation Lookaside Buffer）。
   - 通过调用`flush_tlb`刷新TLB，确保页面映射的有效性。避免因为老旧的TLB条目导致错误的地址访问。

9. **`get_pte`**：获取页表项。
   - 根据虚拟地址从页表中获取对应的页表项，用于后续的页面管理和地址映射。

10. **`swapfs_read`**：从磁盘读取数据。
    - 从磁盘读取数据到内存，主要用于将交换出或换入的页面从磁盘恢复到内存中。

11. **`_fifo_swap_out_victim`**：选择需要换出的页面。
    - FIFO算法的核心，在页面管理中，选择队列中的第一个页面作为需要换出的页面。该页面会被标记为“待换出”，并在之后的操作中执行换出操作。

12. **`_fifo_map_swappable`**：更新页面的交换队列。
    - 将最近使用的页面重新加入队列，确保FIFO队列中的页面按照先进先出的顺序正确换出。



### 流程总结
FIFO（先进先出）页面置换算法是一种简单但有效的内存管理方式，用于在物理内存不足时决定哪些页面需要被换出到磁盘。整个过程的核心思想是将最早进入内存的页面作为最先被换出的页面。具体的过程如下：

- 当系统初始化时，首先调用 `swap_init` 函数初始化交换管理器（`swap_manager`），并配置使用的页面置换算法。在这里，FIFO被选作页面置换的算法。`swapfs_init` 初始化交换文件系统（swapfs），为后续页面换入和换出做准备。此时还会验证交换空间的可用性（例如最大交换偏移量），确保系统具备进行页面交换的能力。
- 当内存中的页面需要被换出时，调用 `swap_out` 函数。此函数会依照FIFO算法选择一个最老的页面作为“受害页面”（victim）。`swap_out_victim` 函数负责从FIFO队列中选择该页面，并通过 `get_pte` 获取页面对应的页表项（PTE）。确保该页面已经存在于内存中且处于有效状态后，调用 `swapfs_write` 将该页面的数据写入磁盘。写入完成后，调用 `free_page` 释放该页面的物理内存，最后调用 `tlb_invalidate` 刷新TLB缓存，确保缓存中不再包含被换出的页面。
- 当一个虚拟地址需要访问的页面不在内存中（即发生缺页异常）时，系统会通过 `swap_in` 函数将页面从磁盘加载到内存中。`swap_in` 根据虚拟地址，通过 `get_pte` 获取该地址的页表项，从交换空间中读取对应的数据，并将数据加载到分配的物理页面中。这个过程通过 `swapfs_read` 来完成，确保磁盘上的页面数据被正确加载到内存中。
   换入的页面需要更新页表，以确保虚拟地址正确映射到物理内存地址。在 `swap_in` 完成数据加载后，会调用 `swap_map_swappable` 函数来建立虚拟地址与物理地址的映射关系，并将页面标记为可交换状态。通过这样的映射，系统能够继续进行内存访问，而无需直接依赖磁盘。
- 随着页面的换入和换出，系统会不断更新内存管理数据结构，如页表和物理页面链表。每次页面换出后，都会释放掉已经不再使用的物理页面，而每次页面换入后，则需要重新分配一个新的物理页面并更新相应的页表项。此外，通过 `tlb_invalidate`，每当页面换入或换出时，都会更新TLB缓存，确保页表和内存中的映射关系是同步的。

通过这些操作，FIFO页面置换算法确保在内存不足时能够按照先入先出的原则，有序地换出不常用的页面，避免内存溢出或程序崩溃。在页面换出时，FIFO算法通过选择最早进入内存的页面作为换出的候选，确保了内存管理的公平性和可预测性。


### 练习2：深入理解不同分页模式的工作原理（思考题）
*get_pte()函数（位于kern/mm/pmm.c）用于在页表中查找或创建页表项，从而实现对指定线性地址对应的物理页的访问和映射操作。这在操作系统中的分页机制下，是实现虚拟内存与物理内存之间映射关系非常重要的内容。
get_pte()函数中有两段形式类似的代码， 结合sv32，sv39，sv48的异同，解释这两段代码为什么如此相像。
目前get_pte()函数将页表项的查找和页表项的分配合并在一个函数里，你认为这种写法好吗？有没有必要把两个功能拆开？*



#### 1. **get_pte()函数的相似性分析**

`get_pte()`函数位于 `kern/mm/pmm.c`，用于在页表中查找或创建页表项，从而实现虚拟地址与物理地址的映射。在这个过程中，`get_pte()`函数通过查找页表项（PTE），根据虚拟地址映射对应的物理页。函数中有两段形式相似的代码，分别处理了不同层级的页表，分别是针对**GiGa Page**（即高层页表）和**MeGa Page**（即较低层页表）。
```c
pte_t *get_pte(pde_t *pgdir, uintptr_t la, bool create) {
    // 获取虚拟地址 la 对应的页目录项
    pde_t *pdep1 = &pgdir[PDX1(la)];
    
    // 如果第一级页表项无效（即页目录项不存在），需要创建新的页表
    if (!(*pdep1 & PTE_V)) {
        struct Page *page;
        if (!create || (page = alloc_page()) == NULL) {
            return NULL;  // 如果无法分配页面，返回 NULL
        }
        set_page_ref(page, 1);  // 设置新分配的页面的引用计数为 1
        uintptr_t pa = page2pa(page);  // 获取物理地址
        memset(KADDR(pa), 0, PGSIZE);  // 将该页的内容清零
        *pdep1 = pte_create(page2ppn(page), PTE_U | PTE_V);  // 创建新的页表项并写入页目录
    }

    // 获取第二级页表项，即通过第一级页表项找到第二级页表
    pde_t *pdep0 = &((pde_t *)KADDR(PDE_ADDR(*pdep1)))[PDX0(la)];
    
    // 如果第二级页表项无效（即页表项不存在），需要创建新的页表
    if (!(*pdep0 & PTE_V)) {
        struct Page *page;
        if (!create || (page = alloc_page()) == NULL) {
            return NULL;  // 如果无法分配页面，返回 NULL
        }
        set_page_ref(page, 1);  // 设置新分配的页面的引用计数为 1
        uintptr_t pa = page2pa(page);  // 获取物理地址
        memset(KADDR(pa), 0, PGSIZE);  // 将该页的内容清零
        *pdep0 = pte_create(page2ppn(page), PTE_U | PTE_V);  // 创建新的页表项并写入页目录
    }

    // 返回最终的页表项，指向目标物理页
    return &((pte_t *)KADDR(PDE_ADDR(*pdep0)))[PTX(la)];
}
```

这两段代码的相似性来自于它们的操作逻辑：都先通过虚拟地址计算出相应的页表项索引（如`PDX1`和`PDX0`），然后在相应的页表中查找该索引对应的地址。如果该页表项不存在（即地址非法），则会为其分配新的页表项。区别在于：

- 第一段代码针对**GiGa Page**，查找的是`PDX1`的页表项，偏移量较高，通常对应更高层次的页表。
- 第二段代码针对**MeGa Page**，查找的是`PDX0`的页表项，偏移量较低，通常对应较低层次的页表。

两段代码逻辑一致，只是在查找的层级（即虚拟地址中的不同偏移部分）和页表项的地址长度上有所区别。

#### 2. **sv32、sv39、sv48的异同**

这三种分页模式本质上都是在虚拟地址与物理地址之间进行映射，只是在页表的结构和地址的位数上有所不同：

- **sv32**：使用32位虚拟地址，地址空间较小，页表只分为两级。
- **sv39**：使用39位虚拟地址，地址空间增大，页表分为三级。
- **sv48**：使用48位虚拟地址，进一步扩大地址空间，页表分为四级。

这三种模式的共同点是都使用页表的层级结构来实现虚拟地址到物理地址的映射，区别仅在于层级数量（即页表项的级数）和虚拟地址的位数。因此，`get_pte()`函数中的两段代码的相似性就在于，尽管虚拟地址的长度和页表的层级不同，但它们都遵循相同的规则：根据虚拟地址计算相应的页表项，进行查找并在必要时分配新的页表项。

#### 3. **是否有必要将两个功能拆开**

当前`get_pte()`函数将页表项的查找和页表项的分配合并在一个函数中。我们认为这种设计是合理的，主要原因如下：

- **减少代码重复**：在大多数情况下，我们只需要在页表项不存在时才会进行分配操作。这意味着查找和分配是紧密相关的，合并在一个函数中可以避免重复编写查找逻辑。
- **提高执行效率**：将两者合并能减少函数调用的开销，尤其是在分页机制中，频繁的查找和创建操作可能影响性能。减少函数调用的深度和频次可以提升效率。
- **简化代码结构**：这种写法使得代码更加简洁，易于理解和维护。

尽管如此，也可以考虑在某些场景下将两者拆开，特别是当我们需要单独优化或扩展查找或分配的功能时。拆分功能可以提高代码的灵活性和可扩展性，便于未来的维护和修改。例如，在某些特殊情况下，可能需要单独处理页表项的创建逻辑，或者根据不同策略优化页表项查找过程。

#### 4. **结论**

总体而言，当前`get_pte()`函数的设计是合适的。在大多数情况下，合并查找和分配功能能有效简化代码，减少重复，提升性能。但也需要考虑未来可能出现的需求变化，是否需要将这两个操作拆开以提高代码的灵活性。

### 练习3：给未被映射的地址映射上物理页（需要编程）



练习3的目标是补充实现 `do_pgfault` 函数，该函数在缺页异常发生时执行。缺页异常通常发生在进程访问未映射的虚拟内存地址时，我们需要根据地址在进程的虚拟内存区域（VMA）中查找相应的映射，并为缺失的页面分配物理内存，最终建立虚拟地址到物理地址的映射。实现过程中还需处理内存访问权限，确保合适的权限映射。


在补充实现 `do_pgfault` 函数之前，我们首先需要了解缺页异常处理的流程和涉及的内存管理结构。`do_pgfault` 的主要职责是处理缺页异常，在虚拟地址未映射时，分配新的物理页面，并根据 VMA 设置访问权限。

### 3.1. `do_pgfault` 函数的工作流程

1. **查找 VMA**：首先，根据传入的地址 `addr` 查找虚拟内存区域（VMA）。VMA 是表示一段连续虚拟内存空间的数据结构，包含该区域的起始地址、结束地址以及访问权限等信息。
   
2. **检查地址有效性**：如果在 `mm` 中没有找到对应的 VMA，或者 `addr` 不在 VMA 的有效范围内，直接返回错误。

3. **检查访问权限**：根据 `VMA` 的权限标志（`VM_WRITE`, `VM_READ` 等），决定如何处理内存页。如果该地址处于 VMA 的写权限范围内，我们将其标记为可写。

4. **查找页表项**：通过虚拟地址计算页表项（PTE），如果页表项不存在，则需要分配新的物理页，初始化页表。

5. **页表分配和映射**：如果页表项已经存在，但标记为交换页面（swapped out），则需要从磁盘交换数据到物理内存，并完成页表的更新。

6. **设置页面为可交换**：最后，设置该页面为可交换状态。

### 3.2 关键部分实现

以下是 `do_pgfault` 函数中的关键步骤和所涉及的函数：

#### 1. 查找虚拟内存区域（VMA）

```c
struct vma_struct *vma = find_vma(mm, addr);
if (vma == NULL || vma->vm_start > addr) {
    cprintf("not valid addr %x, and can not find it in vma\n", addr);
    goto failed;
}
```



#### 2. 查找页表项并分配物理页

我们需要实现从磁盘加载数据到物理页面，并将物理页面映射到逻辑地址空间的功能。当遇到缺页异常时，代码会检查页表项（PTE）是否存在。若不存在（即虚拟地址没有映射到物理页面），则会尝试分配新的物理页面。如果页表项存在，但它是一个交换页面（即页面内容已经被交换到磁盘），则需要从磁盘加载数据到物理页面并更新页表项。


* 页表项为空的处理： 当页表项 *ptep 为 0 时，说明虚拟地址没有映射到物理内存，此时我们需要调用 pgdir_alloc_page 分配新的物理页面。
```c
pte_t *ptep = get_pte(mm->pgdir, addr, 1);
if (*ptep == 0) {
    if (pgdir_alloc_page(mm->pgdir, addr, perm) == NULL) {
        cprintf("pgdir_alloc_page in do_pgfault failed\n");
        goto failed;
    }
} 
```
这段代码会检查当前页表项是否为空。如果为空，则调用 pgdir_alloc_page 为该地址分配一个新的物理页面，并将该页面映射到虚拟地址 addr。如果分配失败，打印错误信息并跳转到失败处理部分。


* 页表项非空，且是交换页面的处理： 当页表项不为空且为交换页面时，我们需要从磁盘加载数据到物理页面。（需要添加的部分）
```c
else {
    /* LAB3 EXERCISE 3: YOUR CODE */
    // 现在我们认为pte是一个交换条目，我们应该从磁盘加载数据并放到带有phy addr的页面，
    // 并将phy addr与逻辑addr映射，触发交换管理器记录该页面的访问情况

    if (swap_init_ok) {
        struct Page *page = NULL;

        // (1) 根据 mm 和 addr，尝试加载对应的磁盘页面内容到内存中
        swap_in(mm, addr, &page);

        // (2) 根据 mm、addr 和 page 设置物理地址和虚拟地址的映射关系
        page_insert(mm->pgdir, page, addr, perm);

        // (3) 设置页面为可交换
        swap_map_swappable(mm, addr, page, 1);

        // 记录页面的虚拟地址
        page->pra_vaddr = addr;
    } else {
        cprintf("no swap_init_ok but ptep is %x, failed\n", *ptep);
        goto failed;
    }
}

```
 在这段代码中，swap_init_ok 用于标记交换机制是否已初始化。如果未初始化，我们无法从磁盘加载数据，因此必须确保 swap_init_ok 为真。 swap_in(mm, addr, &page) 函数负责从磁盘读取对应的页面数据，并将其存放到分配的物理页面 page 中。使用 page_insert(mm->pgdir, page, addr, perm) 将加载的物理页面与虚拟地址 addr 映射。perm 参数确保访问权限的正确设置将该页面标记为可交换，这使得该页面在内存压力较大时可以被交换到磁盘。 page->pra_vaddr = addr 记录页面的虚拟地址，供后续的内存管理使用。

### 3.3 页目录项和页表项对页替换算法的潜在用处
- **页目录项（PDE）**：页目录项指向一个页表，每个页表项对应一个物理页面。页目录项中包含的信息，如页表的起始地址（物理地址），可以帮助操作系统定位虚拟地址的物理页表，并进一步确定虚拟页是否在物理内存中。

- **页表项（PTE）**：每个页表项对应一个虚拟页的物理页映射。它包含了虚拟页到物理页的映射信息，以及该页是否在内存中（通过标志位如 `PTE_P`）、页面是否可写（`PTE_W`）、是否可执行（`PTE_X`）等。此外，页表项还可能包含指向交换空间的标志或指针，指示该页面是否已被交换到磁盘。

在 **页替换算法** 中，页表项的 `PTE` 可以帮助操作系统判断页面是否需要被换出。如果页表项指向的物理页面已被修改并且标记为脏页，则需要将其写回磁盘。否则，页面可以直接交换出去。页面的 `PTE` 还可以帮助操作系统决定哪些页面可以被替换（例如，LRU 算法通过访问位来判断最近未使用的页面）。

### 3.4 缺页服务例程中访问内存时硬件需要做的事情

当缺页服务例程在执行过程中访问内存并发生页访问异常时，硬件将会执行以下操作：

1. **检测异常**：硬件会首先检测到虚拟地址未映射到物理内存，导致发生缺页异常（Page Fault）。

2. **触发中断**：硬件会触发一个中断，将控制权转交给操作系统的缺页异常处理程序。操作系统会根据异常发生的地址（`addr`）查找是否有映射关系，以及是否需要为该地址分配新的物理页面。

3. **保存上下文**：硬件会保存当前执行的上下文（如 CPU 寄存器的内容），以便缺页异常处理完毕后恢复。

4. **查询页表**：硬件会查询当前进程的页表项（PTE），并根据页表项的内容确定如何处理缺页。例如，硬件会查看该页表项是否有效（是否指向一个有效的物理页）。

5. **调用缺页处理程序**：在操作系统层面，操作系统会根据当前页表的状态决定是分配新的物理页面，还是从磁盘加载页面，或者直接返回错误。

6. **恢复执行**：一旦缺页异常处理程序完成后，硬件会恢复执行，继续执行发生异常的指令。


### 3.5 `Page` 数据结构与页目录项、页表项的对应关系

`Page` 数据结构通常是内存管理中的基本单元。它是一个表示内存页面的结构，通常存储页的物理地址、引用计数、状态（如是否被修改）等信息。在一些实现中，`Page` 结构的数组对应于物理内存中的所有页面。

- **与页目录项（PDE）和页表项（PTE）的对应关系**：`Page` 数组中的每一项通常与虚拟地址的页目录项（PDE）和页表项（PTE）有着直接的对应关系。每个 `Page` 结构会记录一个物理页面的详细信息，而每个页表项则映射到这个物理页面。

  - 页目录项（PDE）负责指向页表的物理内存地址。
  - 页表项（PTE）则具体指向一个物理页的地址（即 `Page` 结构中的物理地址）。

当 `Page` 结构中的页面被映射到虚拟地址空间时，页表项将指向该物理页面，形成虚拟地址到物理地址的映射。






### 练习4：补充完成Clock页替换算法（需要编程）

Clock算法也被称为"二次机会算法"或"简单的CLOCK算法"，其核心思想是给那些曾经被访问过的页面一个"第二次机会"，避免将经常使用的页面置换出去。

原理如下：

#### 1、基本结构：

- 维护一个循环链表，存放所有的页面
- 每个页面都有一个访问位(visited bit)，用于标记该页面是否被访问过
- 有一个类似时钟指针的标记(clock hand)，用于遍历这个循环链表

#### 2、算法流程

初始状态：
- 所有新加入的页面，访问位都设为1
- 时钟指针指向最老的页面

当需要替换页面时：
1. 检查当前指针指向的页面：
   - 如果访问位=0：该页面被选作替换页面
   - 如果访问位=1：将访问位改为0，指针移到下一个页面
2. 重复步骤1直到找到可替换的页面

Clock页替换算法所是实现的函数接口与FIFO页替换算法的函数接口一致，均为swap_manager结构体所定义的函数接口，主要函数如下：

好的,我来详细解释Clock算法的每个函数设计说明。

1. _clock_init_mm：初始化页面替换链表和时钟指针
```c
static int
_clock_init_mm(struct mm_struct *mm)
{     

     // 初始化pra_list_head为空链表
     // 初始化当前指针curr_ptr指向pra_list_head，表示当前页面替换位置为链表头
     // 将mm的私有成员指针指向pra_list_head，用于后续的页面替换算法操作

     list_init(&pra_list_head);
     curr_ptr = &pra_list_head;
     mm->sm_priv = &pra_list_head;
     return 0;
}
```

功能：此函数负责初始化Clock算法所需的数据结构。
* 首先调用list_init初始化全局变量pra_list_head，用于构建循环链表结构
* 将curr_ptr指针(时钟指针)初始化为指向链表头
* 将链表头地址存储在mm->sm_priv中，用于后续的页面替换操作

设计说明：在Clock算法中，我们需要一个循环链表来模拟时钟结构，curr_ptr作为时钟指针在链表中循环移动。该函数确保每个进程拥有独立的页面替换机制。

2. _clock_map_swappable：将新页面加入循环链表
```c
static int
_clock_map_swappable(struct mm_struct *mm, uintptr_t addr, struct Page *page, int swap_in)
{
    list_entry_t *entry=&(page->pra_page_link);
 
    assert(entry != NULL && curr_ptr != NULL);
    // 将页面page插入到页面链表pra_list_head的末尾
    // 将页面的visited标志置为1，表示该页面已被访问
    list_entry_t *head=(list_entry_t*) mm->sm_priv;
    // 每次插到尾部，并将访问位设置为1
    list_add_before(head, entry);
    page->visited = 1;
    return 0;
}
```

功能：此函数负责将新页面加入到循环链表中，并初始化其访问位。
* 将新页面添加到链表末尾
* 将页面的访问位(visited)设置为1，表示该页面刚被访问过

设计说明：
* 新加入的页面被放在链表末尾，保持时钟的循环特性
* 访问位设为1给予新页面一次"机会"，避免其刚加入就被替换出去

3. _clock_swap_out_victim：选择被替换的页面
```c
static int
_clock_swap_out_victim(struct mm_struct *mm, struct Page ** ptr_page, int in_tick)
{
     list_entry_t *head=(list_entry_t*) mm->sm_priv;
         assert(head != NULL);
     assert(in_tick==0);
    while (1) {
        // 遍历页面链表pra_list_head，查找最早未被访问的页面
        // 获取当前页面对应的Page结构指针
        // 如果当前页面未被访问，则将该页面从页面链表中删除，并将该页面指针赋值给ptr_page作为换出页面
        // 如果当前页面已被访问，则将visited标志置为0，表示该页面已被重新访问
        if(curr_ptr == head) 
        {
            curr_ptr = list_next(curr_ptr);
            continue;
        }
    //当链表已满时，需要调出块，调出块就是遍历链表，如果标志位为1就置为0，继续遍历，
    //直到遍历到访问位为0的块，将其删去，指针后移，再将调入快插到链表后端
        struct Page *page = le2page(curr_ptr, pra_page_link);
        if(page->visited == 0) {
            cprintf("curr_ptr %p\n", curr_ptr);
            list_entry_t *next = list_next(curr_ptr);
            list_del(curr_ptr);
            *ptr_page = page;
            curr_ptr = next;  
            break;
        }
        else {
            page->visited = 0;
            curr_ptr = list_next(curr_ptr);
        }
    }
    return 0;
}
```

功能：此函数负责选择要被替换出去的页面。
* 时钟指针curr_ptr在循环链表中移动，检查每个页面的访问位
* 如果遇到访问位为0的页面，选择该页面进行替换
* 如果页面访问位为1，将其置为0并继续查找

设计说明：
* 实现了Clock算法的核心思想：给予页面"第二次机会"
* 通过访问位的检查和重置，保证经常使用的页面不会被轻易替换
* 时钟指针的循环移动确保了页面替换的公平性

这种实现体现了Clock算法的特点：既考虑了页面的使用频率（通过访问位），又保持了实现的简单性（通过循环链表和时钟指针）。相比FIFO算法，它能更好地适应程序的局部性原理，提供更好的性能表现。



### 练习5：阅读代码和实现手册，理解页表映射方式相关知识（思考题）

与分级页表相比，一个大页具有如下优势和劣势：

优势：

* 性能更好

	- TLB命中率提高，因为一个TLB表项可以覆盖更大的内存范围

	- 页表层级更少，减少了内存访问次数

	- 页表占用空间更小,节省内存

* 管理简单
	- 页表结构简单,维护成本低
	- 地址转换过程更直接

缺点：

* 内存碎片

	* 大页会造成更严重的内部碎片

	* 内存利用率可能降低

* 灵活性差

	- 不能细粒度地控制内存访问权限，这可能导致严重的安全风险，例如内核代码被篡改

	- 对小块内存分配不友好
	- 难以实现按需分页(demand paging)

安全风险

- 一个页面错误可能影响更大范围的内存
- 权限粒度太粗,可能带来安全隐患



### 扩展练习 Challenge：实现不考虑实现开销和效率的LRU页替换算法（需要编程）

*challenge部分不是必做部分，不过在正确最后会酌情加分。需写出有详细的设计、分析和测试的实验报告。完成出色的可获得适当加分。*

在操作系统中，页面置换算法用于管理有限的物理内存，通过选择合适的页面进行换出，确保系统能够高效运行。LRU（Least Recently Used）算法是一种常见的页面置换策略，它通过记录页面的访问时间来决定哪些页面应该被换出。LRU 算法选择最久未被访问的页面进行换出，保证最近使用的页面始终在内存中。

本实验通过实现一个不考虑开销和效率的 LRU 页替换算法，使用双向链表来模拟 LRU 页替换机制，并进行测试验证。

#### 1._lru_init_mm：初始化页面替换链表
   ```C
    static int _lru_init_mm(struct mm_struct *mm) {
        list_init(&pra_list_head);  // 初始化链表
        mm->sm_priv = &pra_list_head;  // 将链表头部的地址赋值给 mm->sm_priv
        return 0;
    }
   ```
功能：此函数负责初始化页面替换算法所需的数据结构。
- 首先，它调用 list_init 函数初始化全局变量 pra_list_head，这个变量将用于管理页面的替换。
- 然后，将链表的头部地址存储在 mm->sm_priv 中，sm_priv 是 mm_struct 结构体中的一个指针，专门用于存储与当前进程相关的页面替换数据。

设计说明：在 LRU 算法中，我们使用一个链表来管理页面的访问顺序。该函数确保每个进程拥有独立的链表，以便管理该进程的页面替换。

#### 2. _lru_map_swappable：标记页面为可换出
   ```C
 static int _lru_map_swappable(struct mm_struct *mm, uintptr_t addr, struct Page *page, int swap_in) {
     list_entry_t *head = (list_entry_t*) mm->sm_priv;
     list_entry_t *entry = &(page->pra_page_link);
     
     assert(entry != NULL && head != NULL);
     
     // 遍历链表以检查页面是否已经存在
     list_entry_t *le = list_next(head);
     while (le != head) {
         if (le == entry) {
             // 如果页面已在链表中，将其删除
             list_del(entry);
             break;
         }
         le = list_next(le);
     }

     // 将页面插入到链表头部的后面，表示最近使用
     list_add_after(head, entry);
     
     return 0;
 }
   ```
功能：此函数标记页面为可换出页面，并在访问时更新页面的顺序。当页面被访问时，它会被从链表中删除并插入到链表头部，表示这是最近使用的页面。

设计说明：
- 我们遍历链表检查页面是否已存在，如果存在，则将其从链表中删除（移除旧的位置）。
- 然后，将该页面插入到链表的头部，确保其被标记为“最近使用”。
这种操作保证了链表中最前面的页面为最近访问的页面，尾部的页面为最久未访问的页面。

#### 3. _lru_swap_out_victim：选择需要换出的页面
   ```C
 static int _lru_swap_out_victim(struct mm_struct *mm, struct Page **ptr_page, int in_tick) {
     list_entry_t *head = (list_entry_t*) mm->sm_priv;
     assert(head != NULL);
     assert(in_tick == 0);

     // 找到链表尾部的页面（最久未使用的页面）
     list_entry_t *victim = list_prev(head);
     if (victim == head) {
         return -1; // 链表为空，无法找到被替换的页面
     }
     
     list_del(victim); // 从链表中移除该页面
     *ptr_page = le2page(victim, pra_page_link); // 设置被替换页面的指针
     return 0;
 }
   ```
功能：
该函数负责选择需要换出的页面，即链表中尾部的页面（最久未使用的页面）。如果链表为空，表示没有页面可以换出，返回 -1；否则，移除链表尾部的页面，并返回该页面的指针。

设计说明：
- 链表尾部的页面最久未使用，因此最合适用于替换。
- 通过 list_prev 获取链表尾部的页面，使用 list_del 从链表中删除该页面，最后返回页面指针。

#### 4. _lru_check_swap：测试 LRU 页替换算法
   ```C
 static int _lru_check_swap(void) {
     cprintf("write Virt Page c in lru_check_swap\n");
     *(unsigned char *)0x3000 = 0x0c;
     assert(pgfault_num == 4);
     cprintf("write Virt Page a in lru_check_swap\n");
     *(unsigned char *)0x1000 = 0x0a;
     assert(pgfault_num == 4);
     cprintf("write Virt Page d in lru_check_swap\n");
     *(unsigned char *)0x4000 = 0x0d;
     assert(pgfault_num == 4);
     cprintf("write Virt Page b in lru_check_swap\n");
     *(unsigned char *)0x2000 = 0x0b;
     assert(pgfault_num == 4);
     cprintf("write Virt Page e in lru_check_swap\n");
     *(unsigned char *)0x5000 = 0x0e;
     assert(pgfault_num == 5);
     cprintf("write Virt Page b in lru_check_swap\n");
     *(unsigned char *)0x2000 = 0x0b;
     assert(pgfault_num == 5);
     cprintf("write Virt Page a in lru_check_swap\n");
     *(unsigned char *)0x1000 = 0x0a;
     assert(pgfault_num == 6);
     cprintf("write Virt Page b in lru_check_swap\n");
     *(unsigned char *)0x2000 = 0x0b;
     assert(pgfault_num == 7);
     cprintf("write Virt Page c in lru_check_swap\n");
     *(unsigned char *)0x3000 = 0x0c;
     assert(pgfault_num == 8);
     cprintf("write Virt Page d in lru_check_swap\n");
     *(unsigned char *)0x4000 = 0x0d;
     assert(pgfault_num == 9);
     cprintf("write Virt Page e in lru_check_swap\n");
     *(unsigned char *)0x5000 = 0x0e;
     assert(pgfault_num == 10);
     cprintf("write Virt Page a in lru_check_swap\n");
     assert(*(unsigned char *)0x1000 == 0x0a);
     *(unsigned char *)0x1000 = 0x0a;
     assert(pgfault_num == 11);
     return 0;
 }
   ```
功能：
该函数用于测试 LRU 页替换算法的正确性。通过访问不同的虚拟页面并触发页面错误（pgfault_num），验证 LRU 算法是否按照预期替换最久未使用的页面。

设计说明：
- 在每次访问页面时，通过对虚拟地址的访问模拟触发页面错误。
pgfault_num 是用于记录页面错误次数的变量，测试过程中每次访问页面都会增加其值。
- 通过检查 pgfault_num 的值是否符合预期，来验证算法是否正确地执行了页面替换。

#### 5. swap_manager_lru：定义 LRU 页替换管理器
   ```C
 struct swap_manager swap_manager_lru = 
 {
     .name            = "lru swap manager",
     .init            = &_lru_init,
     .init_mm         = &_lru_init_mm,
     .tick_event      = &_lru_tick_event,
     .map_swappable   = &_lru_map_swappable,
     .set_unswappable = &_lru_set_unswappable,
     .swap_out_victim = &_lru_swap_out_victim,
     .check_swap      = &_lru_check_swap,
 };
   ```
功能：
设计了一个 swap_manager 结构体实例，包含了 LRU 页替换算法所需的所有函数。这些函数包括初始化、页面标记为可换出、选择换出页面、测试交换等操作。

#### 实验结果与分析
在进行测试时，_lru_check_swap 函数模拟了多次页面访问，验证了 LRU 算法的有效性。通过访问不同的虚拟页面，测试了页替换过程中最久未使用页面的选择逻辑，并使用 pgfault_num 检查了页面换出的次数。

最终结果显示，LRU 算法能够正确地根据页面的访问顺序选择最久未使用的页面进行替换，并且实验中没有出现意外错误，证明算法的实现是正确的。

#### 总结
本实验通过实现不考虑效率的 LRU 页替换算法，深入理解了操作系统中页面置换的原理。通过使用链表来管理页面访问顺序，我们能够模拟和验证 LRU 算法的正确性，并进行性能测试。

在实际应用中，LRU 算法由于其高效的访问管理机制，被广泛应用于虚拟内存管理中。实验过程中的设计和实现为进一步研究和优化页面替换算法提供了基础。
## 三. 实验中的知识点

### 1. **虚拟内存管理**

- **在实验中**：实验通过实现页表映射、缺页异常处理和页面置换算法构建了基础的虚拟内存管理系统。具体而言，使用mm_struct和vma_struct数据结构管理进程的地址空间，通过页表实现虚拟地址到物理地址的映射关系，并在do_pgfault中处理缺页异常时完成物理页面的分配和映射关系的建立。这些实现共同构成了一个简化但功能完整的虚拟内存管理框架。
- **在OS中**：实际操作系统的虚拟内存管理系统远比实验中的实现复杂。它不仅需要提供进程独立的地址空间以实现内存隔离，还需要支持写时复制、内存共享、文件映射等高级特性。同时，操作系统还需要处理内存碎片、优化内存访问性能、实现高效的地址转换机制，并在多核环境下保证内存访问的一致性。此外，现代操作系统还需要考虑NUMA架构、大页支持等硬件特性，以及针对不同应用场景优化内存管理策略。
- **深入理解**：实验与实际操作系统在虚拟内存管理上的主要差异在于复杂度和完整性。实验聚焦于基本机制的实现，通过简化的场景帮助理解虚拟内存的核心概念。而实际操作系统需要处理更多边界情况和特殊场景，如处理器缓存一致性、TLB管理、内存压缩等。特别是在性能优化方面，实际系统需要平衡多个目标：最小化内存占用、减少页表遍历开销、优化缓存使用等。

### 2. **页面置换算法**

- **在实验中**：实验实现了包括FIFO、Clock和LRU在内的基本页面置换算法，通过swap_manager结构提供了统一的接口。这些算法的实现主要关注基本的置换逻辑，如FIFO通过链表维护页面顺序，Clock算法通过访问位来优化置换决策，而LRU则通过记录页面使用历史来选择最佳的置换候选。实验中的实现相对简单，主要目的是理解算法的核心思想。
- **在OS中**：实际操作系统中的页面置换远比实验复杂，需要考虑多种因素：内存访问模式、进程优先级、页面类型（文件映射、匿名页面等）、硬件特性（如NUMA架构）等。现代操作系统通常采用多层次的页面置换策略，结合主动页面回收、页面预取、内存压缩等技术，以适应不同的工作负载特征。同时，还需要处理页面锁定、直接内存访问（DMA）、设备内存等特殊情况。
- **深入理解**：实验与实际系统在页面置换策略上的差异反映了理论与实践的gap。实验中的算法实现主要服务于教学目的，帮助理解基本原理；而实际系统面临的挑战要复杂得多，需要在多个目标之间权衡：最小化置换开销、优化内存利用率、保证系统响应性等。特别是在现代计算环境下，随着内存层次的复杂化（如持久内存、非易失性内存的引入），页面置换策略需要适应新的硬件特性和应用需求。

### 3. **多级页表机制**

- **在实验中**：实验通过实现两级页表结构和get_pte函数完成了基本的地址转换功能。在这个过程中，我们实现了页表项的查找、创建和权限位设置，建立了虚拟地址到物理地址的映射关系。这种实现虽然简化了实际系统的复杂性，但保留了多级页表的核心特征：通过分级管理减少页表占用的内存空间，同时支持按需分配页表项。实验中的页表操作还需要考虑页表项的有效位、访问位等标志位的管理，这些都是理解页表机制的重要组成部分。
- **在OS中**：现代操作系统的多级页表机制远比实验复杂。首先，主流处理器架构（如x86-64）通常支持四级或五级页表结构，这样可以支持更大的地址空间。其次，实际系统需要处理大页（Huge Pages）机制，通过使用更大的页面大小来减少TLB缺失和页表遍历开销。此外，操作系统还需要实现页表共享机制（如写时复制）、支持地址空间布局随机化（ASLR）、管理TLB（包括TLB刷新策略和多核一致性），以及处理NUMA架构下的页表放置优化等复杂问题。
- **深入理解**：多级页表机制反映了操作系统在空间效率和访问性能之间的权衡。实验的简化实现帮助我们理解基本原理，但实际系统面临的挑战更为复杂。例如，多级页表虽然节省了内存空间，但增加了地址转换的开销，这就需要通过TLB、页表缓存等机制来优化性能。同时，现代系统中的安全需求（如Meltdown/Spectre防护）也对页表机制提出了新的要求，需要在页表设计中考虑安全性。

### 4. **缺页异常处理**

- **在实验中**：实验实现的缺页异常处理主要集中在do_pgfault函数中，处理了最基本的缺页情况：当访问未映射的虚拟地址时，分配物理页面并建立映射关系；当访问被换出的页面时，从磁盘将页面换入内存。这个实现涵盖了异常检测、页面分配、页表映射等基本步骤，为理解缺页异常处理机制提供了清晰的框架。实验中还需要正确处理权限检查和页面状态的转换，这些都是缺页处理的关键环节。
- **在OS中**：实际操作系统的缺页异常处理机制需要处理更多复杂场景。首先，需要区分不同类型的缺页：访问未映射区域、权限违规、写时复制触发、文件映射页面访问等。其次，需要实现智能的页面预取机制，根据访问模式预测并提前加载可能需要的页面。此外，还需要处理共享内存的缺页、跨NUMA节点的页面迁移、透明大页的动态创建等高级特性。在处理这些场景时，还需要考虑性能优化，如批量页面处理、异步IO等技术。
- **深入理解**：缺页异常处理机制展示了操作系统如何通过异常处理来实现复杂的内存管理功能。实验的实现帮助我们理解基本原理，但实际系统的实现需要考虑更多因素：如何最小化缺页处理的延迟、如何在多核系统中高效处理并发缺页、如何利用硬件特性（如异步页面错误）优化性能等。特别是在现代系统中，随着内存层次的复杂化（如持久内存的引入）和新的应用需求（如容器化、实时处理），缺页处理机制需要不断演进以提供更好的性能和功能支持。



## 四、实验中未涉及的知识点

### 1. **内存管理相关**

- **内存压缩技术**：现代操作系统通常会在物理内存紧张时，通过压缩内存页面来延迟或避免页面换出，这是一个在实验中未涉及但实际很重要的优化技术。它涉及压缩算法选择、压缩时机判断、压缩页面的管理等复杂问题。
- **NUMA架构支持**：在多处理器系统中，内存访问延迟取决于处理器和内存的物理位置。操作系统需要考虑内存分配的局部性，实现智能的页面放置和迁移策略，这在实验中完全没有涉及。

### 2. **进程管理相关**

- **实时调度**：实验中的调度器实现相对简单，没有考虑实时任务的调度需求。实际系统中需要处理优先级反转、截止时间保证等问题。
- **CPU亲和性**：在多核系统中，进程调度需要考虑缓存亲和性和NUMA亲和性，这涉及复杂的负载均衡策略。
- **组调度**：现代操作系统支持进程组的概念，需要在组级别进行资源分配和调度决策。

### 3. **文件系统相关**

- **日志文件系统**：实验中的文件系统实现较为基础，没有包含日志机制。而日志对于保证文件系统的一致性和故障恢复非常重要。
- **缓存管理**：实际系统中的页面缓存（Page Cache）和缓冲区缓存（Buffer Cache）管理涉及复杂的预读、回写策略。
- **文件系统快照**：现代文件系统支持快照功能，这需要特殊的数据结构和写时复制机制的支持。

### 4. **安全机制**

- **访问控制列表（ACL）**：比简单的用户权限更复杂的访问控制机制。
- **地址空间布局随机化（ASLR）**：防止缓冲区溢出攻击的重要安全特性。
- **安全隔离机制**：如容器技术中的命名空间隔离、资源限制等。
