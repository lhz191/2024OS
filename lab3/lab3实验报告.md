### 练习

对实验报告的要求：
 - 基于markdown格式来完成，以文本方式为主
 - 填写各个基本练习中要求完成的报告内容
 - 完成实验后，请分析ucore_lab中提供的参考答案，并请在实验报告中说明你的实现与参考答案的区别
 - 列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）
 - 列出你认为OS原理中很重要，但在实验中没有对应上的知识点



# Lab3 缺页异常和页面置换

## 一.实验目的

1.了解虚拟内存的Page Fault异常处理实现

2.了解页替换算法在操作系统中的实现

3.学会如何使用多级页表，处理缺页异常（Page Fault），实现页面置换算法。

## 二.实验过程
### 练习0：填写已有实验

本实验依赖实验2。请把你做的实验2的代码填入本实验中代码中有“LAB2”的注释相应部分。（建议手动补充，不要直接使用merge）


### 练习1：理解基于FIFO的页面替换算法（思考题）
*描述FIFO页面置换算法下，一个页面从被换入到被换出的过程中，会经过代码里哪些函数/宏的处理（或者说，需要调用哪些函数/宏），并用简单的一两句话描述每个函数在过程中做了什么？至少正确指出10个不同的函数分别做了什么？如果少于10个将酌情给分。我们认为只要函数原型不同，就算两个不同的函数。要求指出对执行过程有实际影响,删去后会导致输出结果不同的函数（例如assert）而不是cprintf这样的函数。如果你选择的函数不能完整地体现”从换入到换出“的过程，比如10个函数都是页面换入的时候调用的，或者解释功能的时候只解释了这10个函数在页面换入时的功能，那么也会扣除一定的分数*


FIFO（先进先出）页面置换算法在页面换入和换出过程中会涉及多个函数调用。每个函数的作用具体如下：

1. **`swap_in`**：用于将页面从磁盘换入内存。
   - 通过调用`alloc_page`申请一块新的物理内存，调用`get_pte`获取对应的页表项，最后使用`swapfs_read`从磁盘读取数据到内存中。

2. **`alloc_page`**：用于申请物理页面。
   - 在内存管理器中调用`pmm_manager->alloc_pages`，请求分配一块连续的内存空间。如果分配失败，则会调用`swap_out`换出当前内存中的页面。

3. **`assert(result != NULL)`**：确保页面申请成功。
   - 通过判断返回的页面是否为`NULL`，如果页面为空则会触发错误，避免后续操作出错。

4. **`swap_out`**：用于将页面从内存换出到磁盘。
   - 通过调用`sm->swap_out_victim`选择需要换出的页面，并获取该页面的页表项（`get_pte`）。如果页面被修改过，会调用`swapfs_write`将数据写回磁盘。写入成功后，释放该页面内存；否则调用`_fifo_map_swappable`更新FIFO队列，并刷新TLB。

5. **`free_page`**：释放页面。
   - 调用`pmm_manager->free_pages`释放页面，将其标记为可回收内存，进行内存管理。

6. **`assert((*ptep & PTE_V) != 0);`**：确保页表项合法。
   - 判断页表项的有效位`PTE_V`，确保该页表项是有效的。如果无效，说明页表项不符合交换条件，程序会进入失败状态。

7. **`swapfs_write`**：将页面写回磁盘。
   - 在换出页面时，若页面内容与磁盘上的数据不一致，调用`swapfs_write`将内存中的页面内容写入磁盘。

8. **`tlb_invalidate`**：刷新TLB（Translation Lookaside Buffer）。
   - 通过调用`flush_tlb`刷新TLB，确保页面映射的有效性。避免因为老旧的TLB条目导致错误的地址访问。

9. **`get_pte`**：获取页表项。
   - 根据虚拟地址从页表中获取对应的页表项，用于后续的页面管理和地址映射。

10. **`swapfs_read`**：从磁盘读取数据。
    - 从磁盘读取数据到内存，主要用于将交换出或换入的页面从磁盘恢复到内存中。

11. **`_fifo_swap_out_victim`**：选择需要换出的页面。
    - FIFO算法的核心，在页面管理中，选择队列中的第一个页面作为需要换出的页面。该页面会被标记为“待换出”，并在之后的操作中执行换出操作。

12. **`_fifo_map_swappable`**：更新页面的交换队列。
    - 将最近使用的页面重新加入队列，确保FIFO队列中的页面按照先进先出的顺序正确换出。



### 流程总结
FIFO（先进先出）页面置换算法是一种简单但有效的内存管理方式，用于在物理内存不足时决定哪些页面需要被换出到磁盘。整个过程的核心思想是将最早进入内存的页面作为最先被换出的页面。具体的过程如下：

- 当系统初始化时，首先调用 `swap_init` 函数初始化交换管理器（`swap_manager`），并配置使用的页面置换算法。在这里，FIFO被选作页面置换的算法。`swapfs_init` 初始化交换文件系统（swapfs），为后续页面换入和换出做准备。此时还会验证交换空间的可用性（例如最大交换偏移量），确保系统具备进行页面交换的能力。
- 当内存中的页面需要被换出时，调用 `swap_out` 函数。此函数会依照FIFO算法选择一个最老的页面作为“受害页面”（victim）。`swap_out_victim` 函数负责从FIFO队列中选择该页面，并通过 `get_pte` 获取页面对应的页表项（PTE）。确保该页面已经存在于内存中且处于有效状态后，调用 `swapfs_write` 将该页面的数据写入磁盘。写入完成后，调用 `free_page` 释放该页面的物理内存，最后调用 `tlb_invalidate` 刷新TLB缓存，确保缓存中不再包含被换出的页面。
- 当一个虚拟地址需要访问的页面不在内存中（即发生缺页异常）时，系统会通过 `swap_in` 函数将页面从磁盘加载到内存中。`swap_in` 根据虚拟地址，通过 `get_pte` 获取该地址的页表项，从交换空间中读取对应的数据，并将数据加载到分配的物理页面中。这个过程通过 `swapfs_read` 来完成，确保磁盘上的页面数据被正确加载到内存中。
   换入的页面需要更新页表，以确保虚拟地址正确映射到物理内存地址。在 `swap_in` 完成数据加载后，会调用 `swap_map_swappable` 函数来建立虚拟地址与物理地址的映射关系，并将页面标记为可交换状态。通过这样的映射，系统能够继续进行内存访问，而无需直接依赖磁盘。
- 随着页面的换入和换出，系统会不断更新内存管理数据结构，如页表和物理页面链表。每次页面换出后，都会释放掉已经不再使用的物理页面，而每次页面换入后，则需要重新分配一个新的物理页面并更新相应的页表项。此外，通过 `tlb_invalidate`，每当页面换入或换出时，都会更新TLB缓存，确保页表和内存中的映射关系是同步的。

通过这些操作，FIFO页面置换算法确保在内存不足时能够按照先入先出的原则，有序地换出不常用的页面，避免内存溢出或程序崩溃。在页面换出时，FIFO算法通过选择最早进入内存的页面作为换出的候选，确保了内存管理的公平性和可预测性。


### 练习2：深入理解不同分页模式的工作原理（思考题）
*get_pte()函数（位于kern/mm/pmm.c）用于在页表中查找或创建页表项，从而实现对指定线性地址对应的物理页的访问和映射操作。这在操作系统中的分页机制下，是实现虚拟内存与物理内存之间映射关系非常重要的内容。
get_pte()函数中有两段形式类似的代码， 结合sv32，sv39，sv48的异同，解释这两段代码为什么如此相像。
目前get_pte()函数将页表项的查找和页表项的分配合并在一个函数里，你认为这种写法好吗？有没有必要把两个功能拆开？*



#### 1. **get_pte()函数的相似性分析**

`get_pte()`函数位于 `kern/mm/pmm.c`，用于在页表中查找或创建页表项，从而实现虚拟地址与物理地址的映射。在这个过程中，`get_pte()`函数通过查找页表项（PTE），根据虚拟地址映射对应的物理页。函数中有两段形式相似的代码，分别处理了不同层级的页表，分别是针对**GiGa Page**（即高层页表）和**MeGa Page**（即较低层页表）。
```c
pte_t *get_pte(pde_t *pgdir, uintptr_t la, bool create) {
    // 获取虚拟地址 la 对应的页目录项
    pde_t *pdep1 = &pgdir[PDX1(la)];
    
    // 如果第一级页表项无效（即页目录项不存在），需要创建新的页表
    if (!(*pdep1 & PTE_V)) {
        struct Page *page;
        if (!create || (page = alloc_page()) == NULL) {
            return NULL;  // 如果无法分配页面，返回 NULL
        }
        set_page_ref(page, 1);  // 设置新分配的页面的引用计数为 1
        uintptr_t pa = page2pa(page);  // 获取物理地址
        memset(KADDR(pa), 0, PGSIZE);  // 将该页的内容清零
        *pdep1 = pte_create(page2ppn(page), PTE_U | PTE_V);  // 创建新的页表项并写入页目录
    }

    // 获取第二级页表项，即通过第一级页表项找到第二级页表
    pde_t *pdep0 = &((pde_t *)KADDR(PDE_ADDR(*pdep1)))[PDX0(la)];
    
    // 如果第二级页表项无效（即页表项不存在），需要创建新的页表
    if (!(*pdep0 & PTE_V)) {
        struct Page *page;
        if (!create || (page = alloc_page()) == NULL) {
            return NULL;  // 如果无法分配页面，返回 NULL
        }
        set_page_ref(page, 1);  // 设置新分配的页面的引用计数为 1
        uintptr_t pa = page2pa(page);  // 获取物理地址
        memset(KADDR(pa), 0, PGSIZE);  // 将该页的内容清零
        *pdep0 = pte_create(page2ppn(page), PTE_U | PTE_V);  // 创建新的页表项并写入页目录
    }

    // 返回最终的页表项，指向目标物理页
    return &((pte_t *)KADDR(PDE_ADDR(*pdep0)))[PTX(la)];
}
```

这两段代码的相似性来自于它们的操作逻辑：都先通过虚拟地址计算出相应的页表项索引（如`PDX1`和`PDX0`），然后在相应的页表中查找该索引对应的地址。如果该页表项不存在（即地址非法），则会为其分配新的页表项。区别在于：

- 第一段代码针对**GiGa Page**，查找的是`PDX1`的页表项，偏移量较高，通常对应更高层次的页表。
- 第二段代码针对**MeGa Page**，查找的是`PDX0`的页表项，偏移量较低，通常对应较低层次的页表。

两段代码逻辑一致，只是在查找的层级（即虚拟地址中的不同偏移部分）和页表项的地址长度上有所区别。

#### 2. **sv32、sv39、sv48的异同**

这三种分页模式本质上都是在虚拟地址与物理地址之间进行映射，只是在页表的结构和地址的位数上有所不同：

- **sv32**：使用32位虚拟地址，地址空间较小，页表只分为两级。
- **sv39**：使用39位虚拟地址，地址空间增大，页表分为三级。
- **sv48**：使用48位虚拟地址，进一步扩大地址空间，页表分为四级。

这三种模式的共同点是都使用页表的层级结构来实现虚拟地址到物理地址的映射，区别仅在于层级数量（即页表项的级数）和虚拟地址的位数。因此，`get_pte()`函数中的两段代码的相似性就在于，尽管虚拟地址的长度和页表的层级不同，但它们都遵循相同的规则：根据虚拟地址计算相应的页表项，进行查找并在必要时分配新的页表项。

#### 3. **是否有必要将两个功能拆开**

当前`get_pte()`函数将页表项的查找和页表项的分配合并在一个函数中。我们认为这种设计是合理的，主要原因如下：

- **减少代码重复**：在大多数情况下，我们只需要在页表项不存在时才会进行分配操作。这意味着查找和分配是紧密相关的，合并在一个函数中可以避免重复编写查找逻辑。
- **提高执行效率**：将两者合并能减少函数调用的开销，尤其是在分页机制中，频繁的查找和创建操作可能影响性能。减少函数调用的深度和频次可以提升效率。
- **简化代码结构**：这种写法使得代码更加简洁，易于理解和维护。

尽管如此，也可以考虑在某些场景下将两者拆开，特别是当我们需要单独优化或扩展查找或分配的功能时。拆分功能可以提高代码的灵活性和可扩展性，便于未来的维护和修改。例如，在某些特殊情况下，可能需要单独处理页表项的创建逻辑，或者根据不同策略优化页表项查找过程。

#### 4. **结论**

总体而言，当前`get_pte()`函数的设计是合适的。在大多数情况下，合并查找和分配功能能有效简化代码，减少重复，提升性能。但也需要考虑未来可能出现的需求变化，是否需要将这两个操作拆开以提高代码的灵活性。

### 练习3：给未被映射的地址映射上物理页（需要编程）



练习3的目标是补充实现 `do_pgfault` 函数，该函数在缺页异常发生时执行。缺页异常通常发生在进程访问未映射的虚拟内存地址时，我们需要根据地址在进程的虚拟内存区域（VMA）中查找相应的映射，并为缺失的页面分配物理内存，最终建立虚拟地址到物理地址的映射。实现过程中还需处理内存访问权限，确保合适的权限映射。


在补充实现 `do_pgfault` 函数之前，我们首先需要了解缺页异常处理的流程和涉及的内存管理结构。`do_pgfault` 的主要职责是处理缺页异常，在虚拟地址未映射时，分配新的物理页面，并根据 VMA 设置访问权限。

### 3.1. `do_pgfault` 函数的工作流程

1. **查找 VMA**：首先，根据传入的地址 `addr` 查找虚拟内存区域（VMA）。VMA 是表示一段连续虚拟内存空间的数据结构，包含该区域的起始地址、结束地址以及访问权限等信息。
   
2. **检查地址有效性**：如果在 `mm` 中没有找到对应的 VMA，或者 `addr` 不在 VMA 的有效范围内，直接返回错误。

3. **检查访问权限**：根据 `VMA` 的权限标志（`VM_WRITE`, `VM_READ` 等），决定如何处理内存页。如果该地址处于 VMA 的写权限范围内，我们将其标记为可写。

4. **查找页表项**：通过虚拟地址计算页表项（PTE），如果页表项不存在，则需要分配新的物理页，初始化页表。

5. **页表分配和映射**：如果页表项已经存在，但标记为交换页面（swapped out），则需要从磁盘交换数据到物理内存，并完成页表的更新。

6. **设置页面为可交换**：最后，设置该页面为可交换状态。

### 3.2 关键部分实现

以下是 `do_pgfault` 函数中的关键步骤和所涉及的函数：

#### 1. 查找虚拟内存区域（VMA）

```c
struct vma_struct *vma = find_vma(mm, addr);
if (vma == NULL || vma->vm_start > addr) {
    cprintf("not valid addr %x, and can not find it in vma\n", addr);
    goto failed;
}
```



#### 2. 查找页表项并分配物理页

我们需要实现从磁盘加载数据到物理页面，并将物理页面映射到逻辑地址空间的功能。当遇到缺页异常时，代码会检查页表项（PTE）是否存在。若不存在（即虚拟地址没有映射到物理页面），则会尝试分配新的物理页面。如果页表项存在，但它是一个交换页面（即页面内容已经被交换到磁盘），则需要从磁盘加载数据到物理页面并更新页表项。


* 页表项为空的处理： 当页表项 *ptep 为 0 时，说明虚拟地址没有映射到物理内存，此时我们需要调用 pgdir_alloc_page 分配新的物理页面。
```c
pte_t *ptep = get_pte(mm->pgdir, addr, 1);
if (*ptep == 0) {
    if (pgdir_alloc_page(mm->pgdir, addr, perm) == NULL) {
        cprintf("pgdir_alloc_page in do_pgfault failed\n");
        goto failed;
    }
} 
```
这段代码会检查当前页表项是否为空。如果为空，则调用 pgdir_alloc_page 为该地址分配一个新的物理页面，并将该页面映射到虚拟地址 addr。如果分配失败，打印错误信息并跳转到失败处理部分。


* 页表项非空，且是交换页面的处理： 当页表项不为空且为交换页面时，我们需要从磁盘加载数据到物理页面。（需要添加的部分）
```c
else {
    /* LAB3 EXERCISE 3: YOUR CODE */
    // 现在我们认为pte是一个交换条目，我们应该从磁盘加载数据并放到带有phy addr的页面，
    // 并将phy addr与逻辑addr映射，触发交换管理器记录该页面的访问情况

    if (swap_init_ok) {
        struct Page *page = NULL;

        // (1) 根据 mm 和 addr，尝试加载对应的磁盘页面内容到内存中
        swap_in(mm, addr, &page);

        // (2) 根据 mm、addr 和 page 设置物理地址和虚拟地址的映射关系
        page_insert(mm->pgdir, page, addr, perm);

        // (3) 设置页面为可交换
        swap_map_swappable(mm, addr, page, 1);

        // 记录页面的虚拟地址
        page->pra_vaddr = addr;
    } else {
        cprintf("no swap_init_ok but ptep is %x, failed\n", *ptep);
        goto failed;
    }
}

```
 在这段代码中，swap_init_ok 用于标记交换机制是否已初始化。如果未初始化，我们无法从磁盘加载数据，因此必须确保 swap_init_ok 为真。 swap_in(mm, addr, &page) 函数负责从磁盘读取对应的页面数据，并将其存放到分配的物理页面 page 中。使用 page_insert(mm->pgdir, page, addr, perm) 将加载的物理页面与虚拟地址 addr 映射。perm 参数确保访问权限的正确设置将该页面标记为可交换，这使得该页面在内存压力较大时可以被交换到磁盘。 page->pra_vaddr = addr 记录页面的虚拟地址，供后续的内存管理使用。

### 3.3 页目录项和页表项对页替换算法的潜在用处
- **页目录项（PDE）**：页目录项指向一个页表，每个页表项对应一个物理页面。页目录项中包含的信息，如页表的起始地址（物理地址），可以帮助操作系统定位虚拟地址的物理页表，并进一步确定虚拟页是否在物理内存中。

- **页表项（PTE）**：每个页表项对应一个虚拟页的物理页映射。它包含了虚拟页到物理页的映射信息，以及该页是否在内存中（通过标志位如 `PTE_P`）、页面是否可写（`PTE_W`）、是否可执行（`PTE_X`）等。此外，页表项还可能包含指向交换空间的标志或指针，指示该页面是否已被交换到磁盘。

在 **页替换算法** 中，页表项的 `PTE` 可以帮助操作系统判断页面是否需要被换出。如果页表项指向的物理页面已被修改并且标记为脏页，则需要将其写回磁盘。否则，页面可以直接交换出去。页面的 `PTE` 还可以帮助操作系统决定哪些页面可以被替换（例如，LRU 算法通过访问位来判断最近未使用的页面）。

### 3.4 缺页服务例程中访问内存时硬件需要做的事情

当缺页服务例程在执行过程中访问内存并发生页访问异常时，硬件将会执行以下操作：

1. **检测异常**：硬件会首先检测到虚拟地址未映射到物理内存，导致发生缺页异常（Page Fault）。

2. **触发中断**：硬件会触发一个中断，将控制权转交给操作系统的缺页异常处理程序。操作系统会根据异常发生的地址（`addr`）查找是否有映射关系，以及是否需要为该地址分配新的物理页面。

3. **保存上下文**：硬件会保存当前执行的上下文（如 CPU 寄存器的内容），以便缺页异常处理完毕后恢复。

4. **查询页表**：硬件会查询当前进程的页表项（PTE），并根据页表项的内容确定如何处理缺页。例如，硬件会查看该页表项是否有效（是否指向一个有效的物理页）。

5. **调用缺页处理程序**：在操作系统层面，操作系统会根据当前页表的状态决定是分配新的物理页面，还是从磁盘加载页面，或者直接返回错误。

6. **恢复执行**：一旦缺页异常处理程序完成后，硬件会恢复执行，继续执行发生异常的指令。


### 3.5 `Page` 数据结构与页目录项、页表项的对应关系

`Page` 数据结构通常是内存管理中的基本单元。它是一个表示内存页面的结构，通常存储页的物理地址、引用计数、状态（如是否被修改）等信息。在一些实现中，`Page` 结构的数组对应于物理内存中的所有页面。

- **与页目录项（PDE）和页表项（PTE）的对应关系**：`Page` 数组中的每一项通常与虚拟地址的页目录项（PDE）和页表项（PTE）有着直接的对应关系。每个 `Page` 结构会记录一个物理页面的详细信息，而每个页表项则映射到这个物理页面。

  - 页目录项（PDE）负责指向页表的物理内存地址。
  - 页表项（PTE）则具体指向一个物理页的地址（即 `Page` 结构中的物理地址）。

当 `Page` 结构中的页面被映射到虚拟地址空间时，页表项将指向该物理页面，形成虚拟地址到物理地址的映射。







### 练习4：补充完成Clock页替换算法（需要编程）

### 练习5：阅读代码和实现手册，理解页表映射方式相关知识（思考题）

### 扩展练习 Challenge：实现不考虑实现开销和效率的LRU页替换算法（需要编程）
<<<<<<< HEAD
=======

>>>>>>> c0ac15719574354effa02784fc712ddf3a801253
*challenge部分不是必做部分，不过在正确最后会酌情加分。需写出有详细的设计、分析和测试的实验报告。完成出色的可获得适当加分。*

在操作系统中，页面置换算法用于管理有限的物理内存，通过选择合适的页面进行换出，确保系统能够高效运行。LRU（Least Recently Used）算法是一种常见的页面置换策略，它通过记录页面的访问时间来决定哪些页面应该被换出。LRU 算法选择最久未被访问的页面进行换出，保证最近使用的页面始终在内存中。

本实验通过实现一个不考虑开销和效率的 LRU 页替换算法，使用双向链表来模拟 LRU 页替换机制，并进行测试验证。

#### 1._lru_init_mm：初始化页面替换链表
   ```C
    static int _lru_init_mm(struct mm_struct *mm) {
        list_init(&pra_list_head);  // 初始化链表
        mm->sm_priv = &pra_list_head;  // 将链表头部的地址赋值给 mm->sm_priv
        return 0;
    }
   ```
功能：此函数负责初始化页面替换算法所需的数据结构。
- 首先，它调用 list_init 函数初始化全局变量 pra_list_head，这个变量将用于管理页面的替换。
- 然后，将链表的头部地址存储在 mm->sm_priv 中，sm_priv 是 mm_struct 结构体中的一个指针，专门用于存储与当前进程相关的页面替换数据。

设计说明：在 LRU 算法中，我们使用一个链表来管理页面的访问顺序。该函数确保每个进程拥有独立的链表，以便管理该进程的页面替换。

#### 2. _lru_map_swappable：标记页面为可换出
   ```C
 static int _lru_map_swappable(struct mm_struct *mm, uintptr_t addr, struct Page *page, int swap_in) {
     list_entry_t *head = (list_entry_t*) mm->sm_priv;
     list_entry_t *entry = &(page->pra_page_link);
     
     assert(entry != NULL && head != NULL);
     
     // 遍历链表以检查页面是否已经存在
     list_entry_t *le = list_next(head);
     while (le != head) {
         if (le == entry) {
             // 如果页面已在链表中，将其删除
             list_del(entry);
             break;
         }
         le = list_next(le);
     }

     // 将页面插入到链表头部的后面，表示最近使用
     list_add_after(head, entry);
     
     return 0;
 }
   ```
功能：此函数标记页面为可换出页面，并在访问时更新页面的顺序。当页面被访问时，它会被从链表中删除并插入到链表头部，表示这是最近使用的页面。

设计说明：
- 我们遍历链表检查页面是否已存在，如果存在，则将其从链表中删除（移除旧的位置）。
- 然后，将该页面插入到链表的头部，确保其被标记为“最近使用”。
这种操作保证了链表中最前面的页面为最近访问的页面，尾部的页面为最久未访问的页面。

#### 3. _lru_swap_out_victim：选择需要换出的页面
   ```C
 static int _lru_swap_out_victim(struct mm_struct *mm, struct Page **ptr_page, int in_tick) {
     list_entry_t *head = (list_entry_t*) mm->sm_priv;
     assert(head != NULL);
     assert(in_tick == 0);

     // 找到链表尾部的页面（最久未使用的页面）
     list_entry_t *victim = list_prev(head);
     if (victim == head) {
         return -1; // 链表为空，无法找到被替换的页面
     }
     
     list_del(victim); // 从链表中移除该页面
     *ptr_page = le2page(victim, pra_page_link); // 设置被替换页面的指针
     return 0;
 }
   ```
功能：
该函数负责选择需要换出的页面，即链表中尾部的页面（最久未使用的页面）。如果链表为空，表示没有页面可以换出，返回 -1；否则，移除链表尾部的页面，并返回该页面的指针。

设计说明：
- 链表尾部的页面最久未使用，因此最合适用于替换。
- 通过 list_prev 获取链表尾部的页面，使用 list_del 从链表中删除该页面，最后返回页面指针。

#### 4. _lru_check_swap：测试 LRU 页替换算法
   ```C
 static int _lru_check_swap(void) {
     cprintf("write Virt Page c in lru_check_swap\n");
     *(unsigned char *)0x3000 = 0x0c;
     assert(pgfault_num == 4);
     cprintf("write Virt Page a in lru_check_swap\n");
     *(unsigned char *)0x1000 = 0x0a;
     assert(pgfault_num == 4);
     cprintf("write Virt Page d in lru_check_swap\n");
     *(unsigned char *)0x4000 = 0x0d;
     assert(pgfault_num == 4);
     cprintf("write Virt Page b in lru_check_swap\n");
     *(unsigned char *)0x2000 = 0x0b;
     assert(pgfault_num == 4);
     cprintf("write Virt Page e in lru_check_swap\n");
     *(unsigned char *)0x5000 = 0x0e;
     assert(pgfault_num == 5);
     cprintf("write Virt Page b in lru_check_swap\n");
     *(unsigned char *)0x2000 = 0x0b;
     assert(pgfault_num == 5);
     cprintf("write Virt Page a in lru_check_swap\n");
     *(unsigned char *)0x1000 = 0x0a;
     assert(pgfault_num == 6);
     cprintf("write Virt Page b in lru_check_swap\n");
     *(unsigned char *)0x2000 = 0x0b;
     assert(pgfault_num == 7);
     cprintf("write Virt Page c in lru_check_swap\n");
     *(unsigned char *)0x3000 = 0x0c;
     assert(pgfault_num == 8);
     cprintf("write Virt Page d in lru_check_swap\n");
     *(unsigned char *)0x4000 = 0x0d;
     assert(pgfault_num == 9);
     cprintf("write Virt Page e in lru_check_swap\n");
     *(unsigned char *)0x5000 = 0x0e;
     assert(pgfault_num == 10);
     cprintf("write Virt Page a in lru_check_swap\n");
     assert(*(unsigned char *)0x1000 == 0x0a);
     *(unsigned char *)0x1000 = 0x0a;
     assert(pgfault_num == 11);
     return 0;
 }
   ```
功能：
该函数用于测试 LRU 页替换算法的正确性。通过访问不同的虚拟页面并触发页面错误（pgfault_num），验证 LRU 算法是否按照预期替换最久未使用的页面。

设计说明：
- 在每次访问页面时，通过对虚拟地址的访问模拟触发页面错误。
pgfault_num 是用于记录页面错误次数的变量，测试过程中每次访问页面都会增加其值。
- 通过检查 pgfault_num 的值是否符合预期，来验证算法是否正确地执行了页面替换。

#### 5. swap_manager_lru：定义 LRU 页替换管理器
   ```C
 struct swap_manager swap_manager_lru = 
 {
     .name            = "lru swap manager",
     .init            = &_lru_init,
     .init_mm         = &_lru_init_mm,
     .tick_event      = &_lru_tick_event,
     .map_swappable   = &_lru_map_swappable,
     .set_unswappable = &_lru_set_unswappable,
     .swap_out_victim = &_lru_swap_out_victim,
     .check_swap      = &_lru_check_swap,
 };
   ```
功能：
设计了一个 swap_manager 结构体实例，包含了 LRU 页替换算法所需的所有函数。这些函数包括初始化、页面标记为可换出、选择换出页面、测试交换等操作。

#### 实验结果与分析
在进行测试时，_lru_check_swap 函数模拟了多次页面访问，验证了 LRU 算法的有效性。通过访问不同的虚拟页面，测试了页替换过程中最久未使用页面的选择逻辑，并使用 pgfault_num 检查了页面换出的次数。

最终结果显示，LRU 算法能够正确地根据页面的访问顺序选择最久未使用的页面进行替换，并且实验中没有出现意外错误，证明算法的实现是正确的。

#### 总结
本实验通过实现不考虑效率的 LRU 页替换算法，深入理解了操作系统中页面置换的原理。通过使用链表来管理页面访问顺序，我们能够模拟和验证 LRU 算法的正确性，并进行性能测试。

在实际应用中，LRU 算法由于其高效的访问管理机制，被广泛应用于虚拟内存管理中。实验过程中的设计和实现为进一步研究和优化页面替换算法提供了基础。
## 三. 实验中的知识点



