### 练习

对实验报告的要求：
 - 基于markdown格式来完成，以文本方式为主
 - 填写各个基本练习中要求完成的报告内容
 - 完成实验后，请分析ucore_lab中提供的参考答案，并请在实验报告中说明你的实现与参考答案的区别
 - 列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）
 - 列出你认为OS原理中很重要，但在实验中没有对应上的知识点



# Lab3 缺页异常和页面置换

## 一.实验目的

1.了解虚拟内存的Page Fault异常处理实现

2.了解页替换算法在操作系统中的实现

3.学会如何使用多级页表，处理缺页异常（Page Fault），实现页面置换算法。

## 二.实验过程
### 练习0：填写已有实验

本实验依赖实验2。请把你做的实验2的代码填入本实验中代码中有“LAB2”的注释相应部分。（建议手动补充，不要直接使用merge）


### 练习1：理解基于FIFO的页面替换算法（思考题）
*描述FIFO页面置换算法下，一个页面从被换入到被换出的过程中，会经过代码里哪些函数/宏的处理（或者说，需要调用哪些函数/宏），并用简单的一两句话描述每个函数在过程中做了什么？至少正确指出10个不同的函数分别做了什么？如果少于10个将酌情给分。我们认为只要函数原型不同，就算两个不同的函数。要求指出对执行过程有实际影响,删去后会导致输出结果不同的函数（例如assert）而不是cprintf这样的函数。如果你选择的函数不能完整地体现”从换入到换出“的过程，比如10个函数都是页面换入的时候调用的，或者解释功能的时候只解释了这10个函数在页面换入时的功能，那么也会扣除一定的分数*



### 练习2：深入理解不同分页模式的工作原理（思考题）
*get_pte()函数（位于kern/mm/pmm.c）用于在页表中查找或创建页表项，从而实现对指定线性地址对应的物理页的访问和映射操作。这在操作系统中的分页机制下，是实现虚拟内存与物理内存之间映射关系非常重要的内容。
get_pte()函数中有两段形式类似的代码， 结合sv32，sv39，sv48的异同，解释这两段代码为什么如此相像。
目前get_pte()函数将页表项的查找和页表项的分配合并在一个函数里，你认为这种写法好吗？有没有必要把两个功能拆开？*



#### 1. **get_pte()函数的相似性分析**

`get_pte()`函数位于 `kern/mm/pmm.c`，用于在页表中查找或创建页表项，从而实现虚拟地址与物理地址的映射。在这个过程中，`get_pte()`函数通过查找页表项（PTE），根据虚拟地址映射对应的物理页。函数中有两段形式相似的代码，分别处理了不同层级的页表，分别是针对**GiGa Page**（即高层页表）和**MeGa Page**（即较低层页表）。
```c
pte_t *get_pte(pde_t *pgdir, uintptr_t la, bool create) {
    // 获取虚拟地址 la 对应的页目录项
    pde_t *pdep1 = &pgdir[PDX1(la)];
    
    // 如果第一级页表项无效（即页目录项不存在），需要创建新的页表
    if (!(*pdep1 & PTE_V)) {
        struct Page *page;
        if (!create || (page = alloc_page()) == NULL) {
            return NULL;  // 如果无法分配页面，返回 NULL
        }
        set_page_ref(page, 1);  // 设置新分配的页面的引用计数为 1
        uintptr_t pa = page2pa(page);  // 获取物理地址
        memset(KADDR(pa), 0, PGSIZE);  // 将该页的内容清零
        *pdep1 = pte_create(page2ppn(page), PTE_U | PTE_V);  // 创建新的页表项并写入页目录
    }

    // 获取第二级页表项，即通过第一级页表项找到第二级页表
    pde_t *pdep0 = &((pde_t *)KADDR(PDE_ADDR(*pdep1)))[PDX0(la)];
    
    // 如果第二级页表项无效（即页表项不存在），需要创建新的页表
    if (!(*pdep0 & PTE_V)) {
        struct Page *page;
        if (!create || (page = alloc_page()) == NULL) {
            return NULL;  // 如果无法分配页面，返回 NULL
        }
        set_page_ref(page, 1);  // 设置新分配的页面的引用计数为 1
        uintptr_t pa = page2pa(page);  // 获取物理地址
        memset(KADDR(pa), 0, PGSIZE);  // 将该页的内容清零
        *pdep0 = pte_create(page2ppn(page), PTE_U | PTE_V);  // 创建新的页表项并写入页目录
    }

    // 返回最终的页表项，指向目标物理页
    return &((pte_t *)KADDR(PDE_ADDR(*pdep0)))[PTX(la)];
}
```

这两段代码的相似性来自于它们的操作逻辑：都先通过虚拟地址计算出相应的页表项索引（如`PDX1`和`PDX0`），然后在相应的页表中查找该索引对应的地址。如果该页表项不存在（即地址非法），则会为其分配新的页表项。区别在于：

- 第一段代码针对**GiGa Page**，查找的是`PDX1`的页表项，偏移量较高，通常对应更高层次的页表。
- 第二段代码针对**MeGa Page**，查找的是`PDX0`的页表项，偏移量较低，通常对应较低层次的页表。

两段代码逻辑一致，只是在查找的层级（即虚拟地址中的不同偏移部分）和页表项的地址长度上有所区别。

#### 2. **sv32、sv39、sv48的异同**

这三种分页模式本质上都是在虚拟地址与物理地址之间进行映射，只是在页表的结构和地址的位数上有所不同：

- **sv32**：使用32位虚拟地址，地址空间较小，页表只分为两级。
- **sv39**：使用39位虚拟地址，地址空间增大，页表分为三级。
- **sv48**：使用48位虚拟地址，进一步扩大地址空间，页表分为四级。

这三种模式的共同点是都使用页表的层级结构来实现虚拟地址到物理地址的映射，区别仅在于层级数量（即页表项的级数）和虚拟地址的位数。因此，`get_pte()`函数中的两段代码的相似性就在于，尽管虚拟地址的长度和页表的层级不同，但它们都遵循相同的规则：根据虚拟地址计算相应的页表项，进行查找并在必要时分配新的页表项。

#### 3. **是否有必要将两个功能拆开**

当前`get_pte()`函数将页表项的查找和页表项的分配合并在一个函数中。我们认为这种设计是合理的，主要原因如下：

- **减少代码重复**：在大多数情况下，我们只需要在页表项不存在时才会进行分配操作。这意味着查找和分配是紧密相关的，合并在一个函数中可以避免重复编写查找逻辑。
- **提高执行效率**：将两者合并能减少函数调用的开销，尤其是在分页机制中，频繁的查找和创建操作可能影响性能。减少函数调用的深度和频次可以提升效率。
- **简化代码结构**：这种写法使得代码更加简洁，易于理解和维护。

尽管如此，也可以考虑在某些场景下将两者拆开，特别是当我们需要单独优化或扩展查找或分配的功能时。拆分功能可以提高代码的灵活性和可扩展性，便于未来的维护和修改。例如，在某些特殊情况下，可能需要单独处理页表项的创建逻辑，或者根据不同策略优化页表项查找过程。

#### 4. **结论**

总体而言，当前`get_pte()`函数的设计是合适的。在大多数情况下，合并查找和分配功能能有效简化代码，减少重复，提升性能。但也需要考虑未来可能出现的需求变化，是否需要将这两个操作拆开以提高代码的灵活性。

### 练习3：给未被映射的地址映射上物理页（需要编程）
















### 练习4：补充完成Clock页替换算法（需要编程）

### 练习5：阅读代码和实现手册，理解页表映射方式相关知识（思考题）

### 扩展练习 Challenge：实现不考虑实现开销和效率的LRU页替换算法（需要编程）
## 三. 实验中的知识点

